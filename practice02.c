/*                                                                  test 02 获取股票的最优解
  给定一个数组 prices ，其中 prices[i] 是一支给定股票第 i 天的价格。

设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。

注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

1.输入: prices = [7,1,5,3,6,4]
输出: 7
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 
2输入: prices = [1,2,3,4,5]
输出: 4
解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。
3输入: prices = [7,6,4,3,1]
输出: 0
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。*/
/*数组{7，1，5，3，6，4}*/
#include<stdio.h>
int max(int *arr,int n)
{
	int i;
	int res;
	for(i=0;i<n-1;i++) //此处也可以是n-1，因为最多必须有2次可选择的余地才能进行买入操作，但如果直接是n也行，因为在后面会对n+1进行判断。
	{
		if(arr[i]<arr[i+1])
		{
			//res=arr[i+1]-arr[i];
			//res+=res;                   错误1：此处如果是直接将res赋值；他将会执行自＋ res=res+res；而非是res=res+变化值;
			
			res+=(arr[i+1]-arr[i]);
                      
		      //return res; 错误2：在此处return,就直接退出了循环，导致res的值不能再次变化；	
		}
	}
	return res;
}
int main()
{
	int arr[]={7,1,5,3,6,4};
	int x;
	x=max(arr,6);
	printf("%d\n",x);
}
/*所谓贪心算法，就是选择当前的最好选择，而不考虑整体，不用计较从哪个地方开始下降，哪个地方开始上升，只要发生了上身，全给他选了就完事了。*/
