//test01

//给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。

//不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。
//输入：nums = [1,1,2]
//输出：2, nums = [1,2]
//解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。
//为什么返回数值是整数，但输出的答案是数组呢?

//请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。

//你可以想象内部操作如下:
//nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝
//int len = removeDuplicates(nums);

// 在函数里修改输入数组对于调用者是可见的。
// // 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。
// for (int i = 0; i < len; i++) {
//     print(nums[i]);

#include<stdio.h>
int deletnum(int *arr,int n);
int deletnum(int *arr,int n)
{
	for(int i=0;i<n;i++)
	{	
		int k=arr[i];
		for(int j=i+1;j<n;j++)
		{
			if(arr[j]==k)
			{
				for(int m=j;m<n;m++)
				{
					arr[m]=arr[m+1];
				        arr[n-1]=0;   //这行代码让你的逻辑更加严谨，并没有什么具体实际的意义，因为你的n已经进行了减1。	
					n--;
				}
			}
		}
	}
	return n;
}

int main()
{
	int arr[]={20,20,10,17,10};
	int m;
	m=deletnum(arr,5);
	printf("得到的新数组为:\n");
	//如果是设置成5，那么依然能遍历，其实数组的大小并没有发生任何的改变，只是自己设置的遍历值发生了改变而已。
	for(int i=0;i<5;i++)
	{
		printf("%d\n",arr[i]);
	
	}
	printf("新数组的大小是：%d\n",m);
}

